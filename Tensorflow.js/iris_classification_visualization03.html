<html>
	<head>
		<title>Ch15_2_2c.html</title>
		<!-- 引入 TensorFlow.js 和 TensorFlow.js Vis 庫 -->
		<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"></script>
		<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-vis@latest"></script>
	</head>
	<body>
		<script>
			let data_path = "https://fchart.github.io/test/iris.json";
			const model = tf.sequential(); // 創建一個順序模型

			// 從 JSON 載入資料
			async function getData() {
				const irisDataReq = await fetch(data_path); // 發送請求獲取資料
				const irisData = await irisDataReq.json(); // 將回應解析為 JSON
				// 清理資料，只保留需要的欄位並過濾掉無效值
				const filterData = irisData
					.map((flower) => ({
						sLength: flower.sepalLength, // 花萼長度
						sWidth: flower.sepalWidth, // 花萼寬度
						pLength: flower.petalLength, // 花瓣長度
						pWidth: flower.petalWidth, // 花瓣寬度
						species: flower.species, // 種類
					}))
					.filter(
						(flower) => flower.sLength != null && flower.sWidth != null && flower.pLength != null && flower.pWidth != null && flower.species != null
					); // 過濾掉無效值
				return filterData;
			}

			// 創建模型
			function createModel() {
				// 添加輸入層，4 個神經元，輸入形狀為 4
				model.add(tf.layers.dense({ inputShape: [4], units: 4, activation: "relu" }));
				// 添加輸出層，3 個神經元，使用 softmax 激活函數
				model.add(tf.layers.dense({ units: 3, activation: "softmax" }));
				// 編譯模型，設定損失函數和優化器
				model.compile({ loss: "categoricalCrossentropy", optimizer: tf.train.adam(0.06), metrics: ["accuracy"] });
				tfvis.show.modelSummary({ name: "Model Summary" }, model); // 顯示模型摘要
			}

			// 將資料轉換為 Tensor
			function convertToTensor(data) {
				return tf.tidy(() => {
					tf.util.shuffle(data); // 打亂資料順序
					const inputs = data.map((d) => [d.sLength, d.sWidth, d.pLength, d.pWidth]); // 提取輸入特徵
					const labels = data.map((d) => [
						d.species == "setosa" ? 1 : 0, // Setosa 種類
						d.species == "virginica" ? 1 : 0, // Virginica 種類
						d.species == "versicolor" ? 1 : 0, // Versicolor 種類
					]); // 將種類轉換為 one-hot 編碼
					const inputTensor = tf.tensor2d(inputs, [inputs.length, 4]); // 將輸入轉換為 Tensor
					const labelTensor = tf.tensor2d(labels, [labels.length, 3]); // 將標籤轉換為 Tensor
					return {
						inputs: inputTensor,
						labels: labelTensor,
					};
				});
			}

			// 訓練模型
			async function trainModel(inputs, labels) {
				const batchSize = 16; // 批次大小
				const epochs = 50; // 訓練週期
				return await model.fit(inputs, labels, {
					batchSize,
					epochs,
					shuffle: true, // 每次訓練時打亂資料
					callbacks: tfvis.show.fitCallbacks(
						{ name: "Training Performance" }, // 顯示訓練過程的損失和準確率
						["loss", "acc"], // 監控損失和準確率
						{
							yLabel: "loss/acc", // Y 軸標籤
							height: 200, // 圖表高度
							callbacks: ["onEpochEnd"], // 每個週期結束時更新
						}
					),
				});
			}

			// 測試預測
			function testPredict(index) {
				// 測試資料
				xs = [
					[4.3, 3, 1.1, 0.1], // Setosa 的測試資料
					[6.5, 3, 5.8, 2.2], // Virginica 的測試資料
					[6.6, 2.9, 4.6, 1.3], // Versicolor 的測試資料
				];
				testVal = tf.tensor2d(xs[index], [1, 4]); // 將測試資料轉換為 Tensor
				const prediction = model.predict(testVal); // 使用模型進行預測
				const pIndex = tf.argMax(prediction, (axis = 1)).dataSync(); // 獲取預測結果的索引
				classNames = ["Setosa", "Virginica", "Versicolor"]; // 種類名稱
				document.getElementById("output").innerText = classNames[pIndex] + "\n" + prediction; // 顯示預測結果
			}

			// 主函數
			async function run() {
				createModel(); // 創建模型
				const data = await getData(); // 獲取資料
				const tensorData = convertToTensor(data); // 將資料轉換為 Tensor
				await trainModel(tensorData.inputs, tensorData.labels); // 訓練模型
				document.getElementById("output").innerText = "完成訓練! 請按下方按鈕測試..."; // 更新頁面顯示
				alert("完成訓練..."); // 訓練完成提示
			}

			run(); // 執行主函數
		</script>
		<h1>鳶尾花資料集的多元分類</h1>
		<div id="output">請等待模型訓練中....</div>
		<br />
		<!-- 測試按鈕 -->
		<button onclick="testPredict(0)">測試 Setosa</button>
		<button onclick="testPredict(1)">測試 Virginica</button>
		<button onclick="testPredict(2)">測試 Versicolor</button>
	</body>
</html>
