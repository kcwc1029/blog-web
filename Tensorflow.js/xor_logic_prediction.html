<html>
	<head>
		<title>xor_logic_prediction</title>
		<!-- 引入 TensorFlow.js 和 TensorFlow.js Vis 庫 -->
		<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"></script>
		<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-vis@latest"></script>
	</head>
	<body>
		<h4>XOR 預測結果:</h4>
		<p><span id="output">目前正在訓練中....</span></p>
	</body>
	<script>
		// TODO: 建立模型
		function createModel() {
			let model = tf.sequential(); // 創建一個順序模型
			// 添加隱藏層，8 個神經元，輸入形狀為 2
			model.add(tf.layers.dense({ units: 8, inputShape: 2, activation: "tanh" }));
			// 添加輸出層，1 個神經元，使用 sigmoid 激活函數
			model.add(tf.layers.dense({ units: 1, activation: "sigmoid" }));
			model.compile({
				optimizer: "sgd", // 使用隨機梯度下降（SGD）優化器
				loss: "binaryCrossentropy", // 使用二元交叉熵作為損失函數
				lr: 0.1, // 學習率
				metrics: ["accuracy"], // 評估指標為準確率
			});
			tfvis.show.modelSummary({ name: "Model Summary" }, model); // 顯示模型摘要
			return model;
		}

		// TODO: 訓練資料的張量(XOR)
		const xs = tf.tensor2d([
			[0, 0],
			[0, 1],
			[1, 0],
			[1, 1],
		]);
		const ys = tf.tensor2d([[0], [1], [1], [0]]); // 標籤資料（XOR 的輸出）

		// TODO: 執行訓練（使用 async/await）
		async function trainModel() {
			const model = createModel(); // 創建模型
			// 訓練模型
			await model.fit(xs, ys, {
				batchSize: 1, // 批次大小為 1
				epochs: 300, // 訓練 3000 個週期
				callbacks: tfvis.show.fitCallbacks(
					{ name: "Training Performance" }, // 顯示訓練過程的損失和準確率
					["loss", "acc"], // 監控損失和準確率
					{
						yLabel: "loss/acc", // Y 軸標籤
						height: 200, // 圖表高度
						callbacks: ["onEpochEnd"], // 每個週期結束時更新
					}
				),
			});

			// alert("完成訓練..."); // 訓練完成後彈出提示
			document.getElementById("output").innerText = "預測中..."; // 更新頁面顯示

			// TODO: 預測資料
			const preds = model.predict(xs); // 使用訓練好的模型進行預測
			const array = await preds.array(); // 將預測結果轉換為陣列
			document.getElementById("output").innerText = array; // 將預測結果顯示在頁面上
		}

		trainModel(); // 執行訓練
	</script>
</html>
