<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<title>Ch15_1_3b.html</title>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-vis@latest"></script>
</head>
<body>
<script>
let data_path="https://storage.googleapis.com/tfjs-tutorials/carsData.json";
async function getData() {
  const carsDataReq = await fetch(data_path);
  const carsData = await carsDataReq.json();
  const cleaned = carsData.map(car => ({
    mpg: car.Miles_per_Gallon,
    horsepower: car.Horsepower
  })).filter(car => (car.mpg != null && car.horsepower != null));
  return cleaned;
}  
function createModel() {
  const model = tf.sequential();
  model.add(tf.layers.dense({inputShape: [1], units: 10}));
  model.add(tf.layers.dense({units: 20, activation: "sigmoid"}));
  model.add(tf.layers.dense({units: 20, activation: "sigmoid"}));
  model.add(tf.layers.dense({units: 1}));
  model.compile({loss:"meanSquaredError",optimizer:"adam",metrics:["mse"]});
  tfvis.show.modelSummary({name: "Model Summary"},model);
  return model;
}
function convertToTensor(data) {
  return tf.tidy(() => {
    tf.util.shuffle(data);
    const inputs = data.map(d => d.horsepower);
    const labels = data.map(d => d.mpg);
    const inputTensor = tf.tensor2d(inputs, [inputs.length, 1]);
    const labelTensor = tf.tensor2d(labels, [labels.length, 1]);
    const inputMax = inputTensor.max();
    const inputMin = inputTensor.min();
    const labelMax = labelTensor.max();
    const labelMin = labelTensor.min();
    const normalizedInputs = inputTensor.sub(inputMin).div(inputMax.sub(inputMin));
    const normalizedLabels = labelTensor.sub(labelMin).div(labelMax.sub(labelMin));
    return {
      inputs: normalizedInputs, labels: normalizedLabels,
      inputMax, inputMin, labelMax, labelMin,
    }
  });
}

async function trainModel(model, inputs, labels) {
  const batchSize = 32;
  const epochs = 50;
  return await model.fit(inputs, labels, {
    batchSize, epochs, shuffle: true, 
    callbacks: tfvis.show.fitCallbacks(
      {name: "Training Performance"},
      ["loss", "mse"],
      {height: 200, callbacks: ["onEpochEnd"]})
  });
}

function getPrediction(model, normalizationData) {
  const {inputMax, inputMin, labelMin, labelMax} = normalizationData;
  return tf.tidy(() => {
    const input_x = tf.linspace(0, 1, 100);
    const preds = model.predict(input_x.reshape([100, 1]));
    const toOrignalX = input_x
      .mul(inputMax.sub(inputMin)).add(inputMin);
    const toOrignalY = preds
      .mul(labelMax.sub(labelMin)).add(labelMin);
    return [toOrignalX.dataSync(), toOrignalY.dataSync()];
  });
}

function visualizationPrediction(originalData, predictedData){
  const original = originalData.map(d => ({
    x: d.horsepower, y: d.mpg,
  }));
  const [px, py] = predictedData;
  const predicted = Array.from(px).map((val, i) => {
    return {x: val, y: py[i]}
  });
  tfvis.render.scatterplot(
    { name: "Model Predictions vs Original Data" }, 
    { values: [original, predicted], 
      series: ["original", "predicted"]}, 
    { xLabel: "Horsepower", yLabel: "MPG",
      height: 300 }
  );
}

async function run(){
  const model = createModel();
  const data = await getData();
  const tensorData = convertToTensor(data);
  await trainModel(model, tensorData.inputs, tensorData.labels);
  alert("完成訓練...");
  const predictedData= getPrediction(model, tensorData);
  visualizationPrediction(data, predictedData)
}
run();
</script>
</body>
</html>
